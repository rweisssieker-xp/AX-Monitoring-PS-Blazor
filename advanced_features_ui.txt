    
    # ==========================================
    # LEVEL 3 FEATURES
    # ==========================================
    
    # Business Impact Dashboard
    st.subheader("üí∞ Business Impact Dashboard")
    
    business_impact = calculate_business_impact(df_filtered)
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üì¶ Verz√∂gerte Auftr√§ge", f"{business_impact['delayed_orders']} St√ºck")
    
    with col2:
        st.metric("üíµ Gesch√§tzter Umsatzverlust", f"‚Ç¨{business_impact['revenue_loss']:,.2f}")
    
    with col3:
        st.metric("‚è±Ô∏è Produktivit√§tsverlust", f"{business_impact['productivity_hours']} Stunden")
    
    with col4:
        st.metric("üî¥ Kritische Kunden", business_impact['critical_customers'])
    
    st.markdown("---")
    
    # Success Ranking
    st.subheader("üéØ Performance-Ranking pro Distribution")
    
    ranking = calculate_success_ranking(df_filtered)
    
    if not ranking.empty:
        col1, col2 = st.columns([2, 1])
        
        with col1:
            # Top 3 and Bottom 3
            st.markdown("### üèÜ Top Performer")
            for idx, row in ranking.head(3).iterrows():
                col_a, col_b, col_c, col_d = st.columns([1, 2, 2, 2])
                with col_a:
                    st.write(row['Rank_Icon'])
                with col_b:
                    st.write(f"**{row['Distribution']}**")
                with col_c:
                    st.write(f"{row['Success_Rate']:.1f}% Erfolg")
                with col_d:
                    st.write(f"√ò {row['Avg_Duration']:.1f} min")
            
            if len(ranking) > 3:
                st.markdown("### ‚ö†Ô∏è Verbesserungspotenzial")
                for idx, row in ranking.tail(3).iterrows():
                    with st.expander(f"{row['Rank_Icon']} {row['Distribution']} - Score: {row['Performance_Score']:.1f}"):
                        st.write(f"**Erfolgsrate:** {row['Success_Rate']:.1f}%")
                        st.write(f"**√ò Dauer:** {row['Avg_Duration']:.1f} min")
                        st.write(f"**Fehler:** {row['Errors']} von {row['Total_Jobs']}")
                        st.warning("üí° Empfehlung: Parameter-Optimierung pr√ºfen")
        
        with col2:
            # Performance Score Chart
            fig_ranking = px.bar(
                ranking.head(10),
                x='Performance_Score',
                y='Distribution',
                orientation='h',
                title="Performance Score",
                color='Performance_Score',
                color_continuous_scale=['red', 'yellow', 'green']
            )
            fig_ranking.update_layout(height=400)
            st.plotly_chart(fig_ranking, use_container_width=True)
    
    st.markdown("---")
    
    # Prediction Model
    st.subheader("üîÆ Fehlervorhersage (n√§chste 4 Stunden)")
    
    predictions = predict_next_errors(df_filtered)
    
    if predictions:
        st.warning(f"‚ö†Ô∏è {len(predictions)} potenzielle Fehler vorhergesagt")
        
        for pred in predictions:
            with st.expander(f"{pred['icon']} {pred['time']} - {pred['distribution']} ({pred['probability']}% Wahrscheinlichkeit)"):
                st.write(f"**Grund:** {pred['reason']}")
                st.info("üí° Empfehlung: Monitoring verst√§rken in diesem Zeitfenster")
    else:
        st.success("‚úÖ Keine Fehler in den n√§chsten 4 Stunden erwartet")
    
    st.markdown("---")
    
    # Optimal Runtime
    st.subheader("üóìÔ∏è Optimale Laufzeit-Empfehlungen")
    
    optimal_runtime = get_optimal_runtime_recommendations()
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### ‚úÖ Beste Zeiten")
        for time_slot in optimal_runtime['best_times']:
            st.success(f"{time_slot['icon']} **{time_slot['day']} {time_slot['time']}** - {time_slot['success_rate']}% Erfolgsrate")
    
    with col2:
        st.markdown("### ‚ùå Vermeide")
        for time_slot in optimal_runtime['avoid_times']:
            st.error(f"{time_slot['icon']} **{time_slot['day']} {time_slot['time']}** - {time_slot['success_rate']}% Erfolgsrate\n\n*Grund: {time_slot['reason']}*")
    
    st.markdown("---")
    
    # ==========================================
    # LEVEL 4 FEATURES
    # ==========================================
    
    # Auto-Retry
    st.subheader("üîÑ Smart Retry & Automation")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### üîÑ Intelligent Retry")
        selected_job = st.selectbox(
            "Job ausw√§hlen f√ºr Retry-Simulation",
            ["Distribution 08", "Distribution 14", "Distribution 03"],
            key="retry_job_select"
        )
        
        if st.button("üîç Retry-Strategie analysieren", key="analyze_retry"):
            retry_rec = get_retry_recommendations(selected_job, "Timeout")
            
            st.info(f"‚è∞ Optimal in: **{retry_rec['wait_minutes']} Minuten** ({retry_rec['optimal_time']})")
            st.metric("Erfolgswahrscheinlichkeit", f"{retry_rec['success_probability']}%")
            st.write(f"**Begr√ºndung:** {retry_rec['reason']}")
            
            st.write("**Checks vor Retry:**")
            for check in retry_rec['checks']:
                st.write(f"‚úì {check}")
            
            st.button("üöÄ Smart Retry ausf√ºhren", key="execute_retry", type="primary")
    
    with col2:
        st.markdown("### üìã Playbook f√ºr h√§ufige Fehler")
        
        error_type = st.selectbox(
            "Fehlertyp",
            ["Connection Timeout", "Permission Denied", "Data Not Found"],
            key="playbook_error"
        )
        
        playbook = get_playbook_for_error(error_type.lower())
        
        st.write(f"**{playbook['name']}**")
        st.write(f"Erfolgsquote: **{playbook['success_rate']}%**")
        
        st.write("**Schritte:**")
        for step in playbook['steps']:
            if step['status'] == 'done':
                st.success(f"‚úÖ {step['name']}")
            elif step['status'] == 'pending' and step['auto']:
                st.info(f"‚è≥ {step['name']} (Auto)")
            else:
                st.warning(f"‚è∏Ô∏è {step['name']} (Manuell)")
        
        if st.button("ü§ñ Auto-Fix ausf√ºhren", key="autofix_btn", type="primary"):
            st.success("‚úÖ Auto-Fix wurde gestartet!")
    
    st.markdown("---")
    
    # Parameter Optimizer
    st.subheader("üéõÔ∏è Job-Parameter-Optimizer")
    
    selected_dist = st.selectbox(
        "Distribution f√ºr Optimierung",
        ["Distribution 14", "Distribution 08", "Distribution 12"],
        key="optimizer_dist"
    )
    
    # Simulate slow job
    current_duration = 18
    avg_duration = 10
    
    suggestions = optimize_job_parameters(selected_dist, current_duration, avg_duration)
    
    if suggestions:
        st.warning(f"‚ö†Ô∏è {selected_dist} l√§uft {current_duration/avg_duration:.1f}x langsamer als √ºblich!")
        
        st.write("**üí° Optimierungs-Vorschl√§ge:**")
        
        for sug in suggestions:
            with st.expander(f"{sug['icon']} {sug['parameter']}: {sug['current']} ‚Üí {sug['recommended']}"):
                st.write(f"**Erwarteter Impact:** {sug['impact']}")
                if st.button(f"Anwenden: {sug['parameter']}", key=f"apply_{sug['parameter']}"):
                    st.success(f"‚úÖ {sug['parameter']} wurde optimiert!")
    else:
        st.success("‚úÖ Parameter sind optimal konfiguriert")
    
    st.markdown("---")
    
    # Smart Alerting
    st.subheader("üîî Smart Alerting & Eskalation")
    
    alert_rules = create_alert_rules()
    
    for rule in alert_rules:
        with st.expander(f"üìã {rule['name']}: {rule['condition']}"):
            st.write("**Eskalationsstufen:**")
            for level in rule['levels']:
                st.write(f"‚Ä¢ **{level['time']}:** {level['action']}")
    
    if st.button("‚ûï Neue Alert-Regel erstellen", key="new_alert"):
        st.info("Alert-Regel Editor w√ºrde hier erscheinen")
    
    st.markdown("---")
    
    # ==========================================
    # LEVEL 5 FEATURES
    # ==========================================
    
    # Executive Summary
    st.subheader("üìä Executive Summary")
    
    summary = generate_executive_summary(df_filtered)
    
    if summary:
        st.markdown(f"### W√∂chentlicher Report KW {summary['week_number']}")
        
        # Key Metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Jobs ausgef√ºhrt",
                summary['total_jobs'],
                delta=f"{summary['jobs_change']:+.1f}%"
            )
        
        with col2:
            st.metric(
                "Erfolgsrate",
                f"{summary['success_rate']:.1f}%",
                delta=f"{summary['success_change']:+.1f}%"
            )
        
        with col3:
            st.metric(
                "√ò Laufzeit",
                f"{summary['avg_duration']:.1f} min",
                delta=f"{summary['duration_change']:+.1f}%"
            )
        
        with col4:
            st.metric(
                "Fehler",
                summary['errors'],
                delta="Gesamt"
            )
        
        # Top Issues
        if summary['top_issues']:
            st.markdown("#### ‚ö†Ô∏è Top Issues")
            for issue in summary['top_issues']:
                st.error(f"‚Ä¢ {issue['reason'][:80]} ({issue['count']}x, {issue['percentage']:.1f}%)")
        
        # Trends
        st.markdown("#### üìà Erkannte Trends")
        for trend in summary['trends']:
            st.info(f"‚Ä¢ {trend}")
        
        # Recommendations
        st.markdown("#### üéØ Empfohlene Ma√ünahmen")
        for idx, rec in enumerate(summary['recommendations'], 1):
            st.success(f"{idx}. {rec}")
        
        # Export buttons
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üìÑ PDF Export", key="export_pdf"):
                st.info("PDF-Export w√ºrde hier generiert")
        
        with col2:
            if st.button("üìß Email an Management", key="email_summary"):
                st.success("‚úÖ Email wurde versendet!")
        
        with col3:
            if st.button("üíæ Als Template speichern", key="save_template"):
                st.success("‚úÖ Template gespeichert!")
    
    st.markdown("---")
    
    # ==========================================
    # LEVEL 6 FEATURES
    # ==========================================
    
    # Natural Language Query
    st.subheader("ü§ñ Frag mich was du wissen willst")
    
    nl_query = st.text_input(
        "Deine Frage:",
        placeholder="z.B. 'Warum ist Distribution 08 heute so langsam?'",
        key="nl_query_input"
    )
    
    if nl_query:
        responses = natural_language_query(nl_query, df_filtered)
        
        for response in responses:
            if response['type'] == 'analysis':
                st.markdown(f"### üîç {response['title']}")
                st.write(response['answer'])
                
                if 'causes' in response:
                    st.markdown("**Identifizierte Ursachen:**")
                    for cause in response['causes']:
                        st.write(f"‚Ä¢ {cause}")
                
                if 'recommendation' in response:
                    st.success(f"üí° **Empfehlung:** {response['recommendation']}")
                
                if 'similar_cases' in response:
                    st.caption(f"√Ñhnliche F√§lle: {response['similar_cases']}x in letzten 3 Monaten")
            
            elif response['type'] == 'error_info':
                st.markdown(f"### ‚ö†Ô∏è {response['title']}")
                st.error(response['answer'])
                st.metric("H√§ufigkeit", f"{response['count']}x ({response['percentage']:.1f}%)")
            
            elif response['type'] == 'recommendation':
                st.markdown(f"### üí° {response['title']}")
                st.write(response['answer'])
                for time_slot in response.get('times', []):
                    st.success(f"‚úÖ {time_slot['day']} {time_slot['time']} - {time_slot['success_rate']}% Erfolg")
            
            else:  # info/help
                st.markdown(f"### ‚ÑπÔ∏è {response['title']}")
                st.info(response['answer'])
                if 'examples' in response:
                    st.markdown("**Beispiele:**")
                    for example in response['examples']:
                        st.write(f"‚Ä¢ {example}")
    
    st.markdown("---")
    
    # Pattern Recognition
    st.subheader("üîç Automatisch erkannte Muster")
    
    patterns = detect_patterns(df_filtered)
    
    if patterns:
        for pattern in patterns:
            with st.expander(f"üìä Pattern: {pattern['name']} (Confidence: {pattern['confidence']}%)"):
                st.write(f"**Beobachtung:** {pattern['description']}")
                st.write(f"**Grund:** {pattern['reason']}")
                
                st.markdown("**üí° Empfohlene Auto-Anpassungen:**")
                for rec in pattern['recommendations']:
                    st.write(f"‚Ä¢ {rec}")
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("‚úÖ Aktivieren", key=f"activate_{pattern['name']}"):
                        st.success("‚úÖ Pattern-basierte Anpassung aktiviert!")
                with col2:
                    if st.button("‚è∏Ô∏è Anpassen", key=f"adjust_{pattern['name']}"):
                        st.info("Editor w√ºrde hier erscheinen")
                with col3:
                    if st.button("‚ùå Ablehnen", key=f"reject_{pattern['name']}"):
                        st.warning("Pattern wurde abgelehnt")
    else:
        st.info("Keine signifikanten Muster erkannt")
    
    st.markdown("---")
    
    # Smart Queue Management
    st.subheader("üö¶ Smart Queue Manager")
    
    queue_data = smart_job_prioritization()
    
    st.markdown("### Wartende Jobs")
    
    for job in queue_data['waiting_jobs']:
        col1, col2, col3, col4 = st.columns([1, 3, 2, 2])
        
        with col1:
            st.write(job['icon'])
        
        with col2:
            st.write(f"**{job['name']}** - {job['customer']}")
        
        with col3:
            st.write(f"SLA in {job['sla_minutes']} min")
        
        with col4:
            # Find recommendation
            rec = next((r for r in queue_data['recommendations'] if r['job_id'] == job['id']), None)
            if rec:
                st.caption(rec['action'])
    
    st.markdown("### AI-Empfehlungen")
    
    for rec in queue_data['recommendations']:
        job = next((j for j in queue_data['waiting_jobs'] if j['id'] == rec['job_id']), None)
        if job:
            st.info(f"**{job['name']}:** {rec['action']} - *{rec['reason']}*")
    
    if queue_data['auto_schedule_possible']:
        if st.button("ü§ñ Auto-Schedule ausf√ºhren", key="auto_schedule", type="primary"):
            st.success("‚úÖ Intelligente Scheduling aktiviert!")
    
    st.markdown("---")
    
